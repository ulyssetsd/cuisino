{"version":3,"sources":["../src/main.ts","../src/shared/config.ts","../src/shared/logger.ts","../src/recipes/repository.ts","../src/recipes/recipe.ts","../src/shared/filesystem.ts","../src/extraction/service.ts","../src/extraction/orchestrator.ts","../src/quality/validator.ts","../src/images/processor.ts","../src/analysis/service.ts","../src/app.ts"],"sourcesContent":["#!/usr/bin/env node\r\n/**\r\n * Main entry point for Cuisino Recipe Processor\r\n * Simplified vertical slice architecture\r\n */\r\nimport 'dotenv/config';\r\nimport CuisinoApp from './app.js';\r\n\r\nasync function main(): Promise<void> {\r\n  const app = new CuisinoApp();\r\n\r\n  try {\r\n    await app.run();\r\n    process.exit(0);\r\n  } catch (error) {\r\n    console.error('üí• Application failed:', (error as Error).message);\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\n// Handle graceful shutdown\r\nprocess.on('SIGINT', () => {\r\n  console.log('\\nüõë Graceful shutdown requested');\r\n  process.exit(0);\r\n});\r\n\r\n// Handle unhandled rejections\r\nprocess.on('unhandledRejection', (reason) => {\r\n  console.error('üí• Unhandled rejection:', reason);\r\n  process.exit(1);\r\n});\r\n\r\n// Run if called directly\r\nif (import.meta.url === `file://${process.argv[1]}`) {\r\n  main();\r\n}\r\n\r\nexport { main };\r\n","/**\r\n * Simplified Configuration Manager\r\n * Centralized configuration with environment variables\r\n */\r\nimport 'dotenv/config';\r\nimport type { AppConfig, OpenAIConfig, PathsConfig, ProcessingConfig, QualityConfig, ImagesConfig, ImageCompressionConfig } from '../types/index.js';\r\n\r\nclass Config implements AppConfig {\r\n  public readonly openai: OpenAIConfig;\r\n  public readonly paths: PathsConfig;\r\n  public readonly processing: ProcessingConfig;\r\n  public readonly quality: QualityConfig;\r\n  public readonly images: ImagesConfig;\r\n\r\n  constructor() {\r\n    this.openai = {\r\n      apiKey: process.env.OPENAI_API_KEY || '',\r\n      model: process.env.OPENAI_MODEL || 'gpt-4o',\r\n      maxTokens: parseInt(process.env.MAX_TOKENS || '4000', 10),\r\n    };\r\n\r\n    this.paths = {\r\n      recipes: process.env.INPUT_DIR || './input',\r\n      output: process.env.OUTPUT_DIR || './output',\r\n      temp: './temp',\r\n    };\r\n\r\n    this.processing = {\r\n      retryAttempts: 3,\r\n      delayBetweenRequests: 2000,\r\n      maxConcurrent: 1,\r\n    };\r\n\r\n    this.quality = {\r\n      autoCorrection: process.env.AUTO_CORRECTION === 'true',\r\n      validationThreshold: 0.8,\r\n    };\r\n\r\n    const compression: ImageCompressionConfig = {\r\n      quality: 85,\r\n      progressive: true,\r\n      mozjpeg: true,\r\n    };\r\n\r\n    this.images = {\r\n      compression,\r\n      maxSize: 2048,\r\n    };\r\n  }\r\n\r\n  validate(): boolean {\r\n    if (!this.openai.apiKey) {\r\n      throw new Error('OPENAI_API_KEY is required');\r\n    }\r\n    return true;\r\n  }\r\n}\r\n\r\nexport default new Config();\r\n","/**\r\n * Simplified Logger utility\r\n * Clean, consistent logging across all domains\r\n */\r\nclass Logger {\r\n  static info(message: string, ...args: any[]): void {\r\n    console.log(`‚ÑπÔ∏è  ${message}`, ...args);\r\n  }\r\n\r\n  static success(message: string, ...args: any[]): void {\r\n    console.log(`‚úÖ ${message}`, ...args);\r\n  }\r\n\r\n  static warning(message: string, ...args: any[]): void {\r\n    console.log(`‚ö†Ô∏è  ${message}`, ...args);\r\n  }\r\n\r\n  static error(message: string, ...args: any[]): void {\r\n    console.error(`‚ùå ${message}`, ...args);\r\n  }\r\n\r\n  static progress(current: number, total: number, message: string): void {\r\n    console.log(`üîÑ [${current}/${total}] ${message}`);\r\n  }\r\n\r\n  static section(title: string): void {\r\n    console.log(`\\nüîπ ${title}`);\r\n    console.log('‚îÄ'.repeat(50));\r\n  }\r\n\r\n  static result(stats: Record<string, string | number>): void {\r\n    console.log('\\nüìä Results:');\r\n    Object.entries(stats).forEach(([key, value]) => {\r\n      console.log(`   ${key}: ${value}`);\r\n    });\r\n  }\r\n}\r\n\r\nexport default Logger;\r\n\r\n// Named exports for convenience\r\nexport const info = Logger.info;\r\nexport const success = Logger.success;\r\nexport const warning = Logger.warning;\r\nexport const error = Logger.error;\r\nexport const progress = Logger.progress;\r\nexport const section = Logger.section;\r\nexport const result = Logger.result;\r\n","/**\r\n * Recipe Repository - Simplified data access\r\n * Handles loading and saving recipes with minimal complexity\r\n */\r\nimport { join } from 'path';\r\nimport { fromImagePaths, fromJson } from './recipe.js';\r\nimport {\r\n  listFiles,\r\n  readJson,\r\n  writeJson,\r\n  ensureDir,\r\n} from '../shared/filesystem.js';\r\nimport { info, success } from '../shared/logger.js';\r\nimport type { AppConfig, ImagePair, ProcessingStats } from '../types/index.js';\r\nimport type Recipe from './recipe.js';\r\n\r\nclass RecipeRepository {\r\n  private readonly config: AppConfig;\r\n  private readonly recipesPath: string;\r\n  private readonly outputPath: string;\r\n\r\n  constructor(config: AppConfig) {\r\n    this.config = config;\r\n    this.recipesPath = config.paths.recipes;\r\n    this.outputPath = config.paths.output;\r\n  }\r\n\r\n  // Load recipes from image pairs\r\n  async loadFromImages(): Promise<Recipe[]> {\r\n    const compressedDir = join(this.recipesPath, 'compressed');\r\n    const images = await listFiles(compressedDir, '.jpg');\r\n\r\n    // Group images into pairs (assuming they come in recto/verso pairs)\r\n    const pairs = this.groupImagePairs(images, compressedDir);\r\n\r\n    info(`Found ${pairs.length} image pairs in ${compressedDir}`);\r\n\r\n    return pairs.map((pair, index) =>\r\n      fromImagePaths(\r\n        String(index + 1).padStart(3, '0'),\r\n        pair.recto,\r\n        pair.verso\r\n      )\r\n    );\r\n  }\r\n\r\n  // Load existing recipes from consolidated JSON file\r\n  async loadExistingRecipes(): Promise<Recipe[]> {\r\n    const recipes: Recipe[] = [];\r\n\r\n    // Load from consolidated file only\r\n    const consolidatedPath = join(this.outputPath, 'all_recipes.json');\r\n    const consolidatedData = await readJson<any>(consolidatedPath);\r\n\r\n    if (consolidatedData && consolidatedData.recipes) {\r\n      for (let i = 0; i < consolidatedData.recipes.length; i++) {\r\n        const data = consolidatedData.recipes[i];\r\n        // Generate ID from index if not present\r\n        data.id = data.id || String(i + 1).padStart(3, '0');\r\n\r\n        recipes.push(fromJson(data));\r\n      }\r\n    }\r\n\r\n    info(\r\n      `Loaded ${recipes.length} existing recipes from consolidated file`\r\n    );\r\n    return recipes;\r\n  }\r\n\r\n  // Save single recipe - updates the consolidated file\r\n  async saveRecipe(recipe: Recipe): Promise<void> {\r\n    // For individual saves, we update the consolidated file\r\n    // This is simpler than maintaining individual files\r\n    const existingRecipes = await this.loadExistingRecipes();\r\n    \r\n    // Find and update existing recipe or add new one\r\n    const existingIndex = existingRecipes.findIndex(r => r.id === recipe.id);\r\n    if (existingIndex >= 0) {\r\n      existingRecipes[existingIndex] = recipe;\r\n    } else {\r\n      existingRecipes.push(recipe);\r\n    }\r\n\r\n    await this.saveAllRecipes(existingRecipes);\r\n  }\r\n\r\n  // Save multiple recipes efficiently (batch update)\r\n  async saveRecipes(recipes: Recipe[]): Promise<void> {\r\n    await this.saveAllRecipes(recipes);\r\n  }\r\n\r\n  // Save all recipes as consolidated file\r\n  async saveAllRecipes(recipes: Recipe[], stats: ProcessingStats = {} as ProcessingStats): Promise<string> {\r\n    const data = {\r\n      metadata: {\r\n        totalRecipes: recipes.length,\r\n        generatedAt: new Date().toISOString(),\r\n        ...stats,\r\n      },\r\n      recipes: recipes.map((r) => r.toJson()),\r\n    };\r\n\r\n    const filePath = join(this.outputPath, 'all_recipes.json');\r\n    await writeJson(filePath, data);\r\n\r\n    success(\r\n      `Saved ${recipes.length} recipes to consolidated file: ${filePath}`\r\n    );\r\n    return filePath;\r\n  }\r\n\r\n  // Group images into recto/verso pairs\r\n  groupImagePairs(images: string[], baseDir: string): ImagePair[] {\r\n    const pairs: ImagePair[] = [];\r\n    const sortedImages = images.sort();\r\n\r\n    for (let i = 0; i < sortedImages.length; i += 2) {\r\n      if (i + 1 < sortedImages.length) {\r\n        pairs.push({\r\n          recto: join(baseDir, sortedImages[i]),\r\n          verso: join(baseDir, sortedImages[i + 1]),\r\n        });\r\n      }\r\n    }\r\n\r\n    return pairs;\r\n  }\r\n\r\n  // Ensure output directory exists\r\n  async ensureDirectories(): Promise<void> {\r\n    await ensureDir(this.outputPath);\r\n  }\r\n}\r\n\r\nexport default RecipeRepository;\r\n","/**\r\n * Simplified Recipe Entity\r\n * Core recipe data structure with essential methods\r\n */\r\nimport type { \r\n  RecipeData, \r\n  RecipeIngredient, \r\n  NutritionalInfo, \r\n  RecipeMetadata,\r\n  ValidationResult \r\n} from '../types/index.js';\r\n\r\nclass Recipe implements RecipeData {\r\n  public id: string;\r\n  public rectoPath?: string;\r\n  public versoPath?: string;\r\n\r\n  // Recipe data\r\n  public title?: string;\r\n  public subtitle?: string;\r\n  public cookingTime?: string;\r\n  public difficulty?: string;\r\n  public servings?: string | number;\r\n  public ingredients: RecipeIngredient[];\r\n  public instructions: string[];\r\n  public nutritionalInfo: NutritionalInfo;\r\n  public allergens: string[];\r\n  public tips: string[];\r\n  public tags: string[];\r\n  public image: string;\r\n  public source?: string;\r\n  public metadata: RecipeMetadata;\r\n\r\n  // Status tracking\r\n  public extracted: boolean;\r\n  public validated: boolean;\r\n  public extractedAt?: string;\r\n  public error?: string;\r\n\r\n  constructor(id: string, rectoPath?: string, versoPath?: string) {\r\n    this.id = id;\r\n    this.rectoPath = rectoPath;\r\n    this.versoPath = versoPath;\r\n\r\n    // Recipe data\r\n    this.title = undefined;\r\n    this.subtitle = undefined;\r\n    this.cookingTime = undefined;\r\n    this.difficulty = undefined;\r\n    this.servings = undefined;\r\n    this.ingredients = [];\r\n    this.instructions = [];\r\n    this.nutritionalInfo = {};\r\n    this.allergens = [];\r\n    this.tips = [];\r\n    this.tags = [];\r\n    this.image = '';\r\n    this.source = undefined;\r\n    this.metadata = {};\r\n\r\n    // Status tracking\r\n    this.extracted = false;\r\n    this.validated = false;\r\n    this.extractedAt = undefined;\r\n    this.error = undefined;\r\n  }\r\n\r\n  // Factory method from image paths\r\n  static fromImagePaths(id: string, rectoPath: string, versoPath: string): Recipe {\r\n    return new Recipe(id, rectoPath, versoPath);\r\n  }\r\n\r\n  // Factory method from JSON\r\n  static fromJson(data: any): Recipe {\r\n    const recipe = new Recipe(data.id, data.rectoPath, data.versoPath);\r\n\r\n    // Handle different JSON formats\r\n    if (data.steps) {\r\n      // HelloFresh format from all_recipes.json\r\n      recipe.title = data.title || 'Unknown Recipe';\r\n      recipe.subtitle = data.subtitle;\r\n      recipe.cookingTime = data.duration;\r\n      recipe.difficulty = data.difficulty;\r\n      recipe.servings = data.servings;\r\n      recipe.ingredients = data.ingredients || [];\r\n      recipe.instructions = data.steps\r\n        ? data.steps.map((step: any) => step.text)\r\n        : [];\r\n      recipe.nutritionalInfo = data.nutrition || {};\r\n      recipe.allergens = data.allergens || [];\r\n      recipe.tips = data.tips || [];\r\n      recipe.tags = data.tags || [];\r\n      recipe.image = data.image;\r\n      recipe.source = data.source;\r\n      recipe.metadata = data.metadata || {};\r\n      recipe.extracted = true;\r\n      recipe.validated = false;\r\n      recipe.extractedAt =\r\n        data.metadata?.processedAt || new Date().toISOString();\r\n    } else if (data.title) {\r\n      // New format or already converted\r\n      Object.assign(recipe, data);\r\n    } else {\r\n      // Legacy format - convert from old structure\r\n      recipe.title = data.title || 'Unknown Recipe';\r\n      recipe.cookingTime = data.duration || data.cookingTime;\r\n      recipe.servings = data.servings;\r\n      recipe.ingredients = data.ingredients || [];\r\n      recipe.instructions = data.instructions || [];\r\n      recipe.nutritionalInfo = data.nutritionalInfo || {};\r\n      recipe.extracted = true;\r\n      recipe.validated = false;\r\n      recipe.extractedAt = new Date().toISOString();\r\n    }\r\n\r\n    return recipe;\r\n  }\r\n\r\n  // Update with extraction data\r\n  updateFromExtraction(data: any): void {\r\n    this.title = data.title;\r\n    this.subtitle = data.subtitle;\r\n    this.cookingTime = data.cookingTime || data.duration;\r\n    this.difficulty = data.difficulty;\r\n    this.servings = data.servings;\r\n    this.ingredients = data.ingredients || [];\r\n    this.instructions = data.instructions || [];\r\n    this.nutritionalInfo = data.nutritionalInfo || data.nutrition || {};\r\n    this.allergens = data.allergens || [];\r\n    this.tips = data.tips || [];\r\n    this.tags = data.tags || [];\r\n    this.image = data.image || '';\r\n    this.source = data.source || 'Extracted';\r\n\r\n    this.extracted = true;\r\n    this.extractedAt = new Date().toISOString();\r\n  }\r\n\r\n  // Mark as error\r\n  setError(error: Error): void {\r\n    this.error = error.message;\r\n    this.extracted = false;\r\n    this.validated = false;\r\n  }\r\n\r\n  // Check if needs extraction\r\n  needsExtraction(): boolean {\r\n    return !this.extracted && !this.hasError();\r\n  }\r\n\r\n  // Check if has error\r\n  hasError(): boolean {\r\n    return Boolean(this.error);\r\n  }\r\n\r\n  // Basic validation\r\n  isValid(): ValidationResult {\r\n    const errors: string[] = [];\r\n\r\n    if (!this.title) errors.push('Missing title');\r\n    if (!this.ingredients || this.ingredients.length === 0)\r\n      errors.push('Missing ingredients');\r\n    if (!this.instructions || this.instructions.length === 0)\r\n      errors.push('Missing instructions');\r\n\r\n    return {\r\n      valid: errors.length === 0,\r\n      errors,\r\n    };\r\n  }\r\n\r\n  // Export to JSON (maintaining HelloFresh format)\r\n  toJson(): any {\r\n    // Prepare clean metadata without duplication\r\n    const cleanMetadata = { ...this.metadata };\r\n\r\n    // Only add file paths if they don't already exist in originalFiles\r\n    if (\r\n      !cleanMetadata.originalFiles &&\r\n      (this.rectoPath || this.versoPath)\r\n    ) {\r\n      cleanMetadata.originalFiles = {\r\n        recto: this.rectoPath,\r\n        verso: this.versoPath,\r\n      };\r\n    }\r\n\r\n    // Remove duplicated properties (prefer originalFiles over rectoPath/versoPath)\r\n    if (cleanMetadata.originalFiles) {\r\n      delete cleanMetadata.rectoPath;\r\n      delete cleanMetadata.versoPath;\r\n    }\r\n\r\n    // Add current status\r\n    cleanMetadata.extracted = this.extracted;\r\n    cleanMetadata.validated = this.validated;\r\n    cleanMetadata.extractedAt = this.extractedAt;\r\n    cleanMetadata.error = this.error;\r\n\r\n    return {\r\n      id: this.id,\r\n      title: this.title,\r\n      subtitle: this.subtitle,\r\n      duration: this.cookingTime,\r\n      difficulty: this.difficulty,\r\n      servings: this.servings,\r\n      ingredients: this.ingredients,\r\n      steps: this.instructions.map((instruction) => ({\r\n        text: instruction,\r\n      })),\r\n      nutrition: this.nutritionalInfo,\r\n      allergens: this.allergens || [],\r\n      tips: this.tips || [],\r\n      tags: this.tags || [],\r\n      image: this.image || '',\r\n      source: this.source || 'Extracted',\r\n      metadata: cleanMetadata,\r\n    };\r\n  }\r\n}\r\n\r\nexport default Recipe;\r\nexport const fromImagePaths = Recipe.fromImagePaths;\r\nexport const fromJson = Recipe.fromJson;\r\n","/**\r\n * Simplified File System utilities\r\n * Common file operations used across domains\r\n */\r\nimport fs from 'fs-extra';\r\nimport { dirname } from 'path';\r\n\r\nconst {\r\n  ensureDir: _ensureDir,\r\n  pathExists,\r\n  readJson: _readJson,\r\n  writeJson: _writeJson,\r\n  readdir,\r\n  stat,\r\n  copy,\r\n  writeFile,\r\n} = fs;\r\n\r\nclass FileSystem {\r\n  static async ensureDir(dirPath: string): Promise<void> {\r\n    await _ensureDir(dirPath);\r\n  }\r\n\r\n  static async readJson<T = any>(filePath: string): Promise<T | null> {\r\n    if (!(await pathExists(filePath))) {\r\n      return null;\r\n    }\r\n    return await _readJson(filePath);\r\n  }\r\n\r\n  static async writeJson(filePath: string, data: any, pretty = true): Promise<void> {\r\n    await this.ensureDir(dirname(filePath));\r\n    const options = pretty ? { spaces: 2 } : {};\r\n    await _writeJson(filePath, data, options);\r\n  }\r\n\r\n  static async listFiles(dirPath: string, extension: string | null = null): Promise<string[]> {\r\n    if (!(await pathExists(dirPath))) {\r\n      return [];\r\n    }\r\n\r\n    const files = await readdir(dirPath);\r\n    if (extension) {\r\n      return files.filter((file) =>\r\n        file.toLowerCase().endsWith(extension.toLowerCase())\r\n      );\r\n    }\r\n    return files;\r\n  }\r\n\r\n  static async getFileStats(filePath: string): Promise<fs.Stats | null> {\r\n    if (!(await pathExists(filePath))) {\r\n      return null;\r\n    }\r\n    return await stat(filePath);\r\n  }\r\n\r\n  static async copyFile(src: string, dest: string): Promise<void> {\r\n    await this.ensureDir(dirname(dest));\r\n    await copy(src, dest);\r\n  }\r\n\r\n  static getFileSize(stats: fs.Stats): number {\r\n    return Math.round(stats.size / 1024); // KB\r\n  }\r\n\r\n  static formatFileSize(bytes: number): string {\r\n    if (bytes < 1024) return `${bytes}B`;\r\n    if (bytes < 1024 * 1024) return `${Math.round(bytes / 1024)}KB`;\r\n    return `${Math.round(bytes / (1024 * 1024))}MB`;\r\n  }\r\n\r\n  static async writeText(filePath: string, content: string): Promise<void> {\r\n    await this.ensureDir(dirname(filePath));\r\n    await writeFile(filePath, content, 'utf8');\r\n  }\r\n}\r\n\r\nexport default FileSystem;\r\n\r\n// Named exports for convenience\r\nexport const listFiles = FileSystem.listFiles;\r\nexport const readJson = FileSystem.readJson;\r\nexport const writeJson = FileSystem.writeJson;\r\nexport const ensureDir = FileSystem.ensureDir;\r\nexport const getFileStats = FileSystem.getFileStats;\r\nexport const formatFileSize = FileSystem.formatFileSize;\r\nexport const writeText = FileSystem.writeText;\r\n","/**\r\n * Simplified OpenAI Extraction Service\r\n * Clean, focused recipe extraction from images\r\n */\r\nimport OpenAI from 'openai';\r\nimport { readFileSync } from 'fs';\r\nimport { progress, info, success, error as _error } from '../shared/logger.js';\r\nimport type { AppConfig } from '../types/index.js';\r\nimport type Recipe from '../recipes/recipe.js';\r\n\r\nclass ExtractionService {\r\n  private readonly config: AppConfig;\r\n  private readonly openai: OpenAI;\r\n  private readonly model: string;\r\n  private readonly maxTokens: number;\r\n\r\n  constructor(config: AppConfig) {\r\n    this.config = config;\r\n    this.openai = new OpenAI({\r\n      apiKey: config.openai.apiKey,\r\n    });\r\n    this.model = config.openai.model;\r\n    this.maxTokens = config.openai.maxTokens;\r\n  }\r\n\r\n  // Extract recipe from image pair\r\n  async extractRecipe(recipe: Recipe): Promise<void> {\r\n    if (!recipe.rectoPath || !recipe.versoPath) {\r\n      throw new Error('Recipe must have both recto and verso image paths');\r\n    }\r\n\r\n    try {\r\n      info(`Extracting recipe ${recipe.id}`);\r\n\r\n      const images = await this.prepareImages(recipe.rectoPath, recipe.versoPath);\r\n      \r\n      const completion = await this.openai.chat.completions.create({\r\n        model: this.model,\r\n        max_tokens: this.maxTokens,\r\n        messages: [\r\n          {\r\n            role: 'system',\r\n            content: this.getSystemPrompt(),\r\n          },\r\n          {\r\n            role: 'user',\r\n            content: [\r\n              {\r\n                type: 'text',\r\n                text: this.createExtractionPrompt(),\r\n              },\r\n              ...images,\r\n            ],\r\n          },\r\n        ],\r\n      });\r\n\r\n      const content = completion.choices[0]?.message?.content;\r\n      if (!content) {\r\n        throw new Error('No response from OpenAI');\r\n      }\r\n\r\n      const extractedData = this.parseResponse(content);\r\n      recipe.updateFromExtraction(extractedData);\r\n\r\n      success(`Recipe ${recipe.id} extracted successfully`);\r\n    } catch (error) {\r\n      _error(`Failed to extract recipe ${recipe.id}:`, (error as Error).message);\r\n      recipe.setError(error as Error);\r\n    }\r\n  }\r\n\r\n  // Prepare images for OpenAI\r\n  private async prepareImages(rectoPath: string, versoPath: string): Promise<Array<{ type: 'image_url'; image_url: { url: string; detail: string } }>> {\r\n    const images = [];\r\n\r\n    for (const imagePath of [rectoPath, versoPath]) {\r\n      const imageBuffer = readFileSync(imagePath);\r\n      const base64Image = imageBuffer.toString('base64');\r\n\r\n      images.push({\r\n        type: 'image_url' as const,\r\n        image_url: {\r\n          url: `data:image/jpeg;base64,${base64Image}`,\r\n          detail: 'high',\r\n        },\r\n      });\r\n    }\r\n\r\n    return images;\r\n  }\r\n\r\n  // Create system prompt\r\n  private getSystemPrompt(): string {\r\n    return `You are an expert recipe extraction assistant. Your task is to analyze HelloFresh recipe cards and extract structured recipe data.\r\n\r\nExtract the following information from the recipe cards:\r\n- Title and subtitle\r\n- Cooking time and difficulty\r\n- Servings\r\n- Complete ingredients list with quantities\r\n- Step-by-step instructions\r\n- Nutritional information (if available)\r\n- Allergens and dietary tags\r\n\r\nAlways respond in valid JSON format. Be precise and comprehensive.`;\r\n  }\r\n\r\n  // Create extraction prompt (now simplified for user message)\r\n  private createExtractionPrompt(): string {\r\n    return `Please extract the recipe information from these HelloFresh recipe cards. The first image shows the front of the card, the second shows the back with instructions.\r\n\r\nReturn the data in this JSON format:\r\n{\r\n  \"title\": \"Recipe Title\",\r\n  \"subtitle\": \"Recipe Subtitle (if any)\",\r\n  \"cookingTime\": \"30 min\",\r\n  \"difficulty\": \"Easy/Medium/Hard\",\r\n  \"servings\": 2,\r\n  \"ingredients\": [\r\n    {\r\n      \"name\": \"ingredient name\",\r\n      \"quantity\": \"amount\",\r\n      \"unit\": \"unit\"\r\n    }\r\n  ],\r\n  \"instructions\": [\r\n    \"Step 1 instruction\",\r\n    \"Step 2 instruction\"\r\n  ],\r\n  \"nutritionalInfo\": {\r\n    \"calories\": 500,\r\n    \"carbs\": \"45g\",\r\n    \"protein\": \"30g\",\r\n    \"fat\": \"15g\"\r\n  },\r\n  \"allergens\": [\"allergen1\", \"allergen2\"],\r\n  \"tags\": [\"tag1\", \"tag2\"]\r\n}`;\r\n  }\r\n\r\n  // Parse OpenAI response\r\n  private parseResponse(content: string): any {\r\n    try {\r\n      // Try to extract JSON from the response\r\n      const jsonMatch = content.match(/\\{[\\s\\S]*\\}/);\r\n      const jsonStr = jsonMatch ? jsonMatch[0] : content;\r\n      \r\n      return JSON.parse(jsonStr);\r\n    } catch (error) {\r\n      _error('Failed to parse OpenAI response:', content);\r\n      throw new Error('Invalid JSON response from OpenAI');\r\n    }\r\n  }\r\n\r\n  // Add delay between requests\r\n  async delay(): Promise<void> {\r\n    await new Promise(resolve => \r\n      setTimeout(resolve, this.config.processing.delayBetweenRequests)\r\n    );\r\n  }\r\n}\r\n\r\nexport default ExtractionService;\r\n","/**\r\n * Extraction Orchestrator\r\n * Manages the extraction process with retry logic\r\n */\r\nimport ExtractionService from './service.js';\r\nimport {\r\n  info,\r\n  section,\r\n  progress,\r\n  error as _error,\r\n  result,\r\n  warning,\r\n} from '../shared/logger.js';\r\nimport type { AppConfig } from '../types/index.js';\r\nimport type Recipe from '../recipes/recipe.js';\r\n\r\nclass ExtractionOrchestrator {\r\n  private readonly config: AppConfig;\r\n  private readonly service: ExtractionService;\r\n  private readonly maxRetries: number;\r\n\r\n  constructor(config: AppConfig) {\r\n    this.config = config;\r\n    this.service = new ExtractionService(config);\r\n    this.maxRetries = config.processing.retryAttempts;\r\n  }\r\n\r\n  // Extract all recipes that need extraction\r\n  async extractRecipes(recipes: Recipe[]): Promise<void> {\r\n    const toExtract = recipes.filter((recipe) => recipe.needsExtraction());\r\n\r\n    if (toExtract.length === 0) {\r\n      info('No recipes need extraction');\r\n      return;\r\n    }\r\n\r\n    section(`Extracting ${toExtract.length} recipes`);\r\n\r\n    for (let i = 0; i < toExtract.length; i++) {\r\n      const recipe = toExtract[i];\r\n\r\n      progress(i + 1, toExtract.length, `Processing recipe ${recipe.id}`);\r\n\r\n      try {\r\n        await this.extractWithRetry(recipe);\r\n\r\n        // Delay between requests (except for last one)\r\n        if (i < toExtract.length - 1) {\r\n          await this.service.delay();\r\n        }\r\n      } catch (error) {\r\n        _error(\r\n          `Failed to extract recipe ${recipe.id} after ${this.maxRetries} attempts`\r\n        );\r\n      }\r\n    }\r\n\r\n    const successful = toExtract.filter((r) => r.extracted).length;\r\n    const failed = toExtract.filter((r) => r.hasError()).length;\r\n\r\n    result({\r\n      'Successful extractions': successful,\r\n      'Failed extractions': failed,\r\n      'Success rate': `${Math.round((successful / toExtract.length) * 100)}%`,\r\n    });\r\n  }\r\n\r\n  // Extract single recipe with retry logic\r\n  private async extractWithRetry(recipe: Recipe): Promise<void> {\r\n    let lastError: Error | null = null;\r\n\r\n    for (let attempt = 1; attempt <= this.maxRetries; attempt++) {\r\n      try {\r\n        if (attempt > 1) {\r\n          warning(`Retry attempt ${attempt} for recipe ${recipe.id}`);\r\n          await this.service.delay();\r\n        }\r\n\r\n        await this.service.extractRecipe(recipe);\r\n        return; // Success\r\n      } catch (error) {\r\n        lastError = error as Error;\r\n        if (attempt === this.maxRetries) {\r\n          recipe.setError(lastError);\r\n          throw lastError;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default ExtractionOrchestrator;\r\n","/**\r\n * Simplified Quality Validator\r\n * Clean validation logic for recipe data\r\n */\r\nimport {\r\n  info,\r\n  section,\r\n  success,\r\n  warning,\r\n  result as _result,\r\n} from '../shared/logger.js';\r\nimport type { AppConfig, QualityValidationResult, RecipeIngredient } from '../types/index.js';\r\nimport type Recipe from '../recipes/recipe.js';\r\n\r\nclass QualityValidator {\r\n  private readonly config: AppConfig;\r\n  private readonly threshold: number;\r\n\r\n  constructor(config: AppConfig) {\r\n    this.config = config;\r\n    this.threshold = config.quality.validationThreshold;\r\n  }\r\n\r\n  // Validate all recipes that need quality check\r\n  validateRecipes(recipes: Recipe[]): void {\r\n    const toValidate = recipes.filter(\r\n      (recipe) =>\r\n        recipe.extracted && !recipe.validated && !recipe.hasError()\r\n    );\r\n\r\n    if (toValidate.length === 0) {\r\n      info('No recipes need quality validation');\r\n      return;\r\n    }\r\n\r\n    section(`Validating ${toValidate.length} recipes`);\r\n\r\n    let passed = 0;\r\n    let failed = 0;\r\n\r\n    for (const recipe of toValidate) {\r\n      const result = this.validateRecipe(recipe);\r\n\r\n      if (result.passed) {\r\n        recipe.validated = true;\r\n        passed++;\r\n        success(`Recipe ${recipe.id}: Quality validation passed`);\r\n      } else {\r\n        failed++;\r\n        warning(`Recipe ${recipe.id}: Quality issues found`);\r\n        result.issues.forEach((issue) => warning(`  - ${issue}`));\r\n      }\r\n    }\r\n\r\n    _result({\r\n      'Quality validations passed': passed,\r\n      'Quality validations failed': failed,\r\n      'Quality pass rate': `${Math.round((passed / toValidate.length) * 100)}%`,\r\n    });\r\n  }\r\n\r\n  // Validate single recipe\r\n  validateRecipe(recipe: Recipe): QualityValidationResult {\r\n    const issues: string[] = [];\r\n    let score = 0;\r\n    const maxScore = 5;\r\n\r\n    // Validate title\r\n    if (this.validateTitle(recipe.title)) {\r\n      score++;\r\n    } else {\r\n      issues.push('Title is missing or too short');\r\n    }\r\n\r\n    // Validate ingredients\r\n    if (this.validateIngredients(recipe.ingredients)) {\r\n      score++;\r\n    } else {\r\n      issues.push('Ingredients list is incomplete or missing quantities');\r\n    }\r\n\r\n    // Validate instructions\r\n    if (this.validateInstructions(recipe.instructions)) {\r\n      score++;\r\n    } else {\r\n      issues.push('Instructions are missing or too brief');\r\n    }\r\n\r\n    // Validate cooking time\r\n    if (this.validateCookingTime(recipe.cookingTime)) {\r\n      score++;\r\n    } else {\r\n      issues.push('Cooking time information is missing or invalid');\r\n    }\r\n\r\n    // Validate servings\r\n    if (this.validateServings(recipe.servings)) {\r\n      score++;\r\n    } else {\r\n      issues.push('Servings information is missing or invalid');\r\n    }\r\n\r\n    const qualityScore = score / maxScore;\r\n    const passed = qualityScore >= this.threshold;\r\n\r\n    return {\r\n      passed,\r\n      score: qualityScore,\r\n      issues,\r\n      needsCorrection: !passed && issues.length > 0,\r\n    };\r\n  }\r\n\r\n  // Validate title\r\n  private validateTitle(title?: string): boolean {\r\n    return Boolean(title && title.trim().length >= 3);\r\n  }\r\n\r\n  // Validate ingredients\r\n  private validateIngredients(ingredients: RecipeIngredient[]): boolean {\r\n    if (!ingredients || ingredients.length === 0) return false;\r\n\r\n    // Check if most ingredients have names and some have quantities\r\n    const withNames = ingredients.filter((ing) => ing.name?.trim()).length;\r\n    const withQuantities = ingredients.filter((ing) => \r\n      ing.quantity?.trim() || ing.unit?.trim()\r\n    ).length;\r\n\r\n    return (\r\n      withNames >= ingredients.length * 0.8 && // 80% have names\r\n      withQuantities >= ingredients.length * 0.5 // 50% have quantities\r\n    );\r\n  }\r\n\r\n  // Validate instructions\r\n  private validateInstructions(instructions: string[]): boolean {\r\n    if (!instructions || instructions.length === 0) return false;\r\n\r\n    // Check if instructions are detailed enough\r\n    const validInstructions = instructions.filter(\r\n      (instruction) => instruction.trim().length >= 10\r\n    );\r\n\r\n    return validInstructions.length >= Math.min(instructions.length * 0.8, 3);\r\n  }\r\n\r\n  // Validate cooking time\r\n  private validateCookingTime(cookingTime?: string): boolean {\r\n    if (!cookingTime) return false;\r\n\r\n    const timeStr = cookingTime.toString().toLowerCase();\r\n    return (\r\n      timeStr.includes('min') ||\r\n      timeStr.includes('h') ||\r\n      /\\d+/.test(timeStr)\r\n    );\r\n  }\r\n\r\n  // Validate servings\r\n  private validateServings(servings?: string | number): boolean {\r\n    if (!servings) return false;\r\n\r\n    const servingStr = servings.toString().toLowerCase();\r\n    return (\r\n      /\\d+/.test(servingStr) ||\r\n      servingStr.includes('portion') ||\r\n      servingStr.includes('pers')\r\n    );\r\n  }\r\n}\r\n\r\nexport default QualityValidator;\r\n","/**\r\n * Simplified Image Processor\r\n * Clean image optimization and analysis\r\n */\r\nimport sharp from 'sharp';\r\nimport { join } from 'path';\r\nimport {\r\n  listFiles,\r\n  getFileStats,\r\n  ensureDir,\r\n  formatFileSize,\r\n} from '../shared/filesystem.js';\r\nimport {\r\n  section,\r\n  result,\r\n  progress,\r\n  error as _error,\r\n} from '../shared/logger.js';\r\nimport type { \r\n  AppConfig, \r\n  ImagePair, \r\n  ImageStats, \r\n  ImageProcessingResult, \r\n  ImageCompressionConfig \r\n} from '../types/index.js';\r\n\r\nclass ImageProcessor {\r\n  private readonly config: AppConfig;\r\n  private readonly compression: ImageCompressionConfig;\r\n  private readonly maxSize: number;\r\n\r\n  constructor(config: AppConfig) {\r\n    this.config = config;\r\n    this.compression = config.images.compression;\r\n    this.maxSize = config.images.maxSize;\r\n  }\r\n\r\n  // Analyze images in directory\r\n  async analyzeImages(inputDir: string): Promise<ImageStats> {\r\n    section('Analyzing images');\r\n\r\n    const images = await listFiles(inputDir, '.jpg');\r\n    const pairs = this.groupImagePairs(images);\r\n\r\n    let totalSize = 0;\r\n    let minSize = Infinity;\r\n    let maxSize = 0;\r\n\r\n    for (const pair of pairs) {\r\n      const rectoStats = await getFileStats(join(inputDir, pair.recto));\r\n      const versoStats = await getFileStats(join(inputDir, pair.verso));\r\n\r\n      if (rectoStats && versoStats) {\r\n        totalSize += rectoStats.size + versoStats.size;\r\n        minSize = Math.min(minSize, rectoStats.size, versoStats.size);\r\n        maxSize = Math.max(maxSize, rectoStats.size, versoStats.size);\r\n      }\r\n    }\r\n\r\n    const stats: ImageStats = {\r\n      totalImages: images.length,\r\n      imagePairs: pairs.length,\r\n      totalSizeMB: Math.round(totalSize / (1024 * 1024)),\r\n      minSizeKB: Math.round(minSize / 1024),\r\n      maxSizeKB: Math.round(maxSize / 1024),\r\n      avgSizeKB: Math.round(totalSize / images.length / 1024),\r\n      estimatedCost: this.estimateProcessingCost(pairs.length),\r\n    };\r\n\r\n    result(stats);\r\n    return stats;\r\n  }\r\n\r\n  // Optimize images for processing\r\n  async optimizeImages(inputDir: string, outputDir: string): Promise<ImageProcessingResult> {\r\n    section('Optimizing images');\r\n\r\n    await ensureDir(outputDir);\r\n\r\n    const images = await listFiles(inputDir, '.jpg');\r\n    let processed = 0;\r\n    let totalSizeBefore = 0;\r\n    let totalSizeAfter = 0;\r\n\r\n    for (let i = 0; i < images.length; i++) {\r\n      const filename = images[i];\r\n      const inputPath = join(inputDir, filename);\r\n      const outputPath = join(outputDir, filename);\r\n\r\n      progress(i + 1, images.length, `Processing ${filename}`);\r\n\r\n      try {\r\n        const beforeStats = await getFileStats(inputPath);\r\n        if (beforeStats) {\r\n          totalSizeBefore += beforeStats.size;\r\n        }\r\n\r\n        await this.processImage(inputPath, outputPath);\r\n\r\n        const afterStats = await getFileStats(outputPath);\r\n        if (afterStats) {\r\n          totalSizeAfter += afterStats.size;\r\n        }\r\n\r\n        processed++;\r\n      } catch (error) {\r\n        _error(`Failed to process ${filename}: ${(error as Error).message}`);\r\n      }\r\n    }\r\n\r\n    const compressionRate = Math.round(\r\n      (1 - totalSizeAfter / totalSizeBefore) * 100\r\n    );\r\n\r\n    const resultData: ImageProcessingResult = {\r\n      'Images processed': processed,\r\n      'Size before': formatFileSize(totalSizeBefore),\r\n      'Size after': formatFileSize(totalSizeAfter),\r\n      'Compression rate': `${compressionRate}%`,\r\n    };\r\n\r\n    result(resultData);\r\n    return resultData;\r\n  }\r\n\r\n  // Process single image\r\n  private async processImage(inputPath: string, outputPath: string): Promise<void> {\r\n    await sharp(inputPath)\r\n      .resize(this.maxSize, this.maxSize, {\r\n        fit: 'inside',\r\n        withoutEnlargement: true,\r\n      })\r\n      .jpeg({\r\n        quality: this.compression.quality,\r\n        progressive: this.compression.progressive,\r\n        mozjpeg: this.compression.mozjpeg,\r\n      })\r\n      .toFile(outputPath);\r\n  }\r\n\r\n  // Group images into pairs (assuming sequential naming)\r\n  private groupImagePairs(images: string[]): ImagePair[] {\r\n    const pairs: ImagePair[] = [];\r\n    const sortedImages = images.sort();\r\n\r\n    for (let i = 0; i < sortedImages.length; i += 2) {\r\n      if (i + 1 < sortedImages.length) {\r\n        pairs.push({\r\n          recto: sortedImages[i],\r\n          verso: sortedImages[i + 1],\r\n        });\r\n      }\r\n    }\r\n\r\n    return pairs;\r\n  }\r\n\r\n  // Estimate processing cost\r\n  private estimateProcessingCost(pairCount: number): number {\r\n    // Rough estimate: $0.01 per image pair for GPT-4V\r\n    return Math.round(pairCount * 0.02 * 100) / 100;\r\n  }\r\n}\r\n\r\nexport default ImageProcessor;\r\n","/**\r\n * Simplified Analysis Service\r\n * Clean reporting and statistics generation\r\n */\r\nimport { join } from 'path';\r\nimport { writeJson, writeText } from '../shared/filesystem.js';\r\nimport { section, success, result } from '../shared/logger.js';\r\nimport type { \r\n  AppConfig, \r\n  AnalysisStats, \r\n  AnalysisReport, \r\n  RecipeIngredient \r\n} from '../types/index.js';\r\nimport type Recipe from '../recipes/recipe.js';\r\n\r\nclass AnalysisService {\r\n  private readonly config: AppConfig;\r\n  private readonly outputPath: string;\r\n\r\n  constructor(config: AppConfig) {\r\n    this.config = config;\r\n    this.outputPath = config.paths.output;\r\n  }\r\n\r\n  // Generate comprehensive report\r\n  async generateReport(recipes: Recipe[]): Promise<AnalysisReport> {\r\n    section('Generating analysis report');\r\n\r\n    const stats = this.calculateStatistics(recipes);\r\n    const report = this.buildReport(stats);\r\n\r\n    // Save JSON report\r\n    const jsonPath = join(this.outputPath, 'analysis_report.json');\r\n    await writeJson(jsonPath, report);\r\n\r\n    // Save Markdown report\r\n    const markdownPath = join(this.outputPath, 'analysis_report.md');\r\n    const markdown = this.generateMarkdown(report);\r\n    await writeText(markdownPath, markdown);\r\n\r\n    success(`Analysis report saved to ${jsonPath} and ${markdownPath}`);\r\n    this.logSummary(stats);\r\n\r\n    return report;\r\n  }\r\n\r\n  // Calculate statistics from recipes\r\n  calculateStatistics(recipes: Recipe[]): AnalysisStats {\r\n    const total = recipes.length;\r\n    const extracted = recipes.filter((r) => r.extracted).length;\r\n    const validated = recipes.filter((r) => r.validated).length;\r\n    const withErrors = recipes.filter((r) => r.hasError()).length;\r\n\r\n    // Ingredient analysis\r\n    const allIngredients = recipes\r\n      .filter((r) => r.ingredients)\r\n      .flatMap((r) => r.ingredients)\r\n      .filter((i): i is RecipeIngredient => Boolean(i && i.name));\r\n\r\n    const ingredientCounts = this.countOccurrences(\r\n      allIngredients.map((i) => i.name.toLowerCase())\r\n    );\r\n    const avgIngredientsPerRecipe =\r\n      allIngredients.length / Math.max(extracted, 1);\r\n\r\n    // Cooking time analysis\r\n    const cookingTimes = recipes\r\n      .filter((r) => r.cookingTime)\r\n      .map((r) => this.extractMinutes(r.cookingTime!))\r\n      .filter((t) => t > 0);\r\n\r\n    const avgCookingTime =\r\n      cookingTimes.length > 0\r\n        ? Math.round(\r\n            cookingTimes.reduce((a, b) => a + b, 0) /\r\n              cookingTimes.length\r\n          )\r\n        : 0;\r\n\r\n    // Quality analysis\r\n    const qualityIssues = recipes.filter(\r\n      (r) => r.extracted && !r.validated\r\n    ).length;\r\n\r\n    return {\r\n      total,\r\n      extracted,\r\n      validated,\r\n      withErrors,\r\n      successRate: Math.round((extracted / total) * 100),\r\n      qualityRate: Math.round((validated / Math.max(extracted, 1)) * 100),\r\n      avgIngredientsPerRecipe:\r\n        Math.round(avgIngredientsPerRecipe * 10) / 10,\r\n      avgCookingTime,\r\n      qualityIssues,\r\n      topIngredients: Object.entries(ingredientCounts)\r\n        .sort(([, a], [, b]) => b - a)\r\n        .slice(0, 10)\r\n        .map(([name, count]) => ({ name, count })),\r\n      errors: recipes\r\n        .filter((r) => r.hasError())\r\n        .map((r) => ({\r\n          id: r.id,\r\n          error: r.error!,\r\n          timestamp: r.extractedAt,\r\n        })),\r\n    };\r\n  }\r\n\r\n  // Build structured report\r\n  private buildReport(stats: AnalysisStats): AnalysisReport {\r\n    return {\r\n      metadata: {\r\n        generatedAt: new Date().toISOString(),\r\n        version: '1.0.0',\r\n      },\r\n      summary: {\r\n        totalRecipes: stats.total,\r\n        successfulExtractions: stats.extracted,\r\n        validatedRecipes: stats.validated,\r\n        failedExtractions: stats.withErrors,\r\n        successRate: `${stats.successRate}%`,\r\n        qualityRate: `${stats.qualityRate}%`,\r\n      },\r\n      insights: {\r\n        averageIngredientsPerRecipe: stats.avgIngredientsPerRecipe,\r\n        averageCookingTimeMinutes: stats.avgCookingTime,\r\n        qualityIssuesCount: stats.qualityIssues,\r\n        topIngredients: stats.topIngredients,\r\n      },\r\n      issues: {\r\n        extractionErrors: stats.errors,\r\n        qualityIssuesCount: stats.qualityIssues,\r\n      },\r\n    };\r\n  }\r\n\r\n  // Generate Markdown report\r\n  private generateMarkdown(report: AnalysisReport): string {\r\n    return `# Recipe Analysis Report\r\n\r\nGenerated on: ${new Date(report.metadata.generatedAt).toLocaleString()}\r\n\r\n## Summary\r\n\r\n- **Total Recipes**: ${report.summary.totalRecipes}\r\n- **Successful Extractions**: ${report.summary.successfulExtractions}\r\n- **Validated Recipes**: ${report.summary.validatedRecipes}\r\n- **Failed Extractions**: ${report.summary.failedExtractions}\r\n- **Success Rate**: ${report.summary.successRate}\r\n- **Quality Rate**: ${report.summary.qualityRate}\r\n\r\n## Insights\r\n\r\n### Recipe Characteristics\r\n- **Average Ingredients per Recipe**: ${report.insights.averageIngredientsPerRecipe}\r\n- **Average Cooking Time**: ${report.insights.averageCookingTimeMinutes} minutes\r\n- **Quality Issues**: ${report.insights.qualityIssuesCount}\r\n\r\n### Top Ingredients\r\n${report.insights.topIngredients.map((ing) => `- ${ing.name}: ${ing.count} recipes`).join('\\n')}\r\n\r\n## Issues\r\n\r\n### Extraction Errors\r\n${\r\n  report.issues.extractionErrors.length > 0\r\n    ? report.issues.extractionErrors\r\n        .map((err) => `- Recipe ${err.id}: ${err.error}`)\r\n        .join('\\n')\r\n    : '- No extraction errors'\r\n}\r\n\r\n### Quality Issues\r\n- **Recipes with quality issues**: ${report.issues.qualityIssuesCount}\r\n\r\n---\r\n*Report generated by Cuisino Recipe Processor*`;\r\n  }\r\n\r\n  // Count occurrences in array\r\n  private countOccurrences(items: string[]): Record<string, number> {\r\n    const counts: Record<string, number> = {};\r\n    \r\n    for (const item of items) {\r\n      counts[item] = (counts[item] || 0) + 1;\r\n    }\r\n    \r\n    return counts;\r\n  }\r\n\r\n  // Extract minutes from cooking time string\r\n  private extractMinutes(timeStr: string): number {\r\n    const match = timeStr.match(/(\\d+)/);\r\n    if (!match) return 0;\r\n\r\n    const value = parseInt(match[1], 10);\r\n    \r\n    if (timeStr.toLowerCase().includes('h')) {\r\n      return value * 60;\r\n    }\r\n    \r\n    return value; // Assume minutes\r\n  }\r\n\r\n  // Log summary to console\r\n  private logSummary(stats: AnalysisStats): void {\r\n    result({\r\n      'Total recipes': stats.total,\r\n      'Successful extractions': stats.extracted,\r\n      'Validation rate': `${stats.qualityRate}%`,\r\n      'Average cooking time': `${stats.avgCookingTime} min`,\r\n      'Average ingredients': stats.avgIngredientsPerRecipe,\r\n    });\r\n  }\r\n}\r\n\r\nexport default AnalysisService;\r\n","/**\r\n * Main Application Orchestrator\r\n * Simplified main entry point that coordinates all domains\r\n */\r\nimport config from './shared/config.js';\r\nimport Logger from './shared/logger.js';\r\n\r\n// Domain services\r\nimport RecipeRepository from './recipes/repository.js';\r\nimport ExtractionOrchestrator from './extraction/orchestrator.js';\r\nimport QualityValidator from './quality/validator.js';\r\nimport ImageProcessor from './images/processor.js';\r\nimport AnalysisService from './analysis/service.js';\r\n\r\nimport type { ProcessingStats, ImageStats, ImageProcessingResult } from './types/index.js';\r\nimport type Recipe from './recipes/recipe.js';\r\n\r\nclass CuisinoApp {\r\n  private readonly recipeRepo: RecipeRepository;\r\n  private readonly extractor: ExtractionOrchestrator;\r\n  private readonly qualityValidator: QualityValidator;\r\n  private readonly imageProcessor: ImageProcessor;\r\n  private readonly analysisService: AnalysisService;\r\n\r\n  constructor() {\r\n    // Validate configuration\r\n    config.validate();\r\n\r\n    // Initialize domain services\r\n    this.recipeRepo = new RecipeRepository(config);\r\n    this.extractor = new ExtractionOrchestrator(config);\r\n    this.qualityValidator = new QualityValidator(config);\r\n    this.imageProcessor = new ImageProcessor(config);\r\n    this.analysisService = new AnalysisService(config);\r\n  }\r\n\r\n  // Main processing pipeline\r\n  async run(): Promise<void> {\r\n    try {\r\n      Logger.section('üç≥ Cuisino Recipe Processor');\r\n      const startTime = Date.now();\r\n\r\n      // Setup\r\n      await this.recipeRepo.ensureDirectories();\r\n\r\n      // Load recipes (from images and existing data)\r\n      const recipes = await this.loadRecipes();\r\n\r\n      if (recipes.length === 0) {\r\n        Logger.warning('No recipes found to process');\r\n        return;\r\n      }\r\n\r\n      // Extract recipes from images\r\n      await this.extractor.extractRecipes(recipes);\r\n\r\n      // Validate data quality\r\n      this.qualityValidator.validateRecipes(recipes);\r\n\r\n      // Save all results\r\n      await this.saveResults(recipes);\r\n\r\n      // Generate analysis report\r\n      await this.analysisService.generateReport(recipes);\r\n\r\n      // Final summary\r\n      const duration = Math.round((Date.now() - startTime) / 1000);\r\n      Logger.section(`‚ú® Processing completed in ${duration}s`);\r\n    } catch (error) {\r\n      Logger.error('Application failed:', (error as Error).message);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Analyze images only (no processing)\r\n  async analyzeImages(): Promise<ImageStats> {\r\n    Logger.section('üîç Image Analysis Mode');\r\n\r\n    const inputDir = config.paths.recipes + '/compressed';\r\n    return await this.imageProcessor.analyzeImages(inputDir);\r\n  }\r\n\r\n  // Optimize images only\r\n  async optimizeImages(): Promise<ImageProcessingResult> {\r\n    Logger.section('üé® Image Optimization Mode');\r\n\r\n    const inputDir = config.paths.recipes + '/uncompressed';\r\n    const outputDir = config.paths.recipes + '/compressed';\r\n\r\n    return await this.imageProcessor.optimizeImages(inputDir, outputDir);\r\n  }\r\n\r\n  // Load recipes from various sources\r\n  private async loadRecipes(): Promise<Recipe[]> {\r\n    Logger.section('Loading recipes');\r\n\r\n    // Try to load existing recipes first\r\n    let recipes = await this.recipeRepo.loadExistingRecipes();\r\n\r\n    // If no existing recipes, load from images\r\n    if (recipes.length === 0) {\r\n      recipes = await this.recipeRepo.loadFromImages();\r\n    }\r\n\r\n    Logger.info(`Loaded ${recipes.length} recipes total`);\r\n    return recipes;\r\n  }\r\n\r\n  // Save all results\r\n  private async saveResults(recipes: Recipe[]): Promise<void> {\r\n    Logger.section('Saving results');\r\n\r\n    // Save individual recipes\r\n    for (const recipe of recipes) {\r\n      if (recipe.extracted || recipe.hasError()) {\r\n        await this.recipeRepo.saveRecipe(recipe);\r\n      }\r\n    }\r\n\r\n    // Save consolidated file\r\n    const stats = this.calculateStats(recipes);\r\n    await this.recipeRepo.saveAllRecipes(recipes, stats);\r\n\r\n    Logger.success('All results saved successfully');\r\n  }\r\n\r\n  // Calculate processing statistics\r\n  private calculateStats(recipes: Recipe[]): ProcessingStats {\r\n    const extracted = recipes.filter((r) => r.extracted).length;\r\n    const validated = recipes.filter((r) => r.validated).length;\r\n    const errors = recipes.filter((r) => r.hasError()).length;\r\n\r\n    return {\r\n      totalRecipes: recipes.length,\r\n      extractedRecipes: extracted,\r\n      validatedRecipes: validated,\r\n      errorCount: errors,\r\n      successRate: `${Math.round((extracted / recipes.length) * 100)}%`,\r\n      qualityRate: `${Math.round((validated / Math.max(extracted, 1)) * 100)}%`,\r\n    };\r\n  }\r\n}\r\n\r\nexport default CuisinoApp;\r\n"],"mappings":"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","names":["error","error","error","result","join","join","error","join","join","service_default","service_default","error","error"]}