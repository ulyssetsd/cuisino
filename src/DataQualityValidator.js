const OpenAI = require('openai');

class DataQualityValidator {
    constructor(openaiClient, config = null) {
        this.openai = openaiClient;
        this.config = config;
        this.model = process.env.OPENAI_MODEL || 'gpt-4o';
        this.maxTokens = parseInt(process.env.MAX_TOKENS) || 2048; // Moins de tokens pour correction
          // Unit√©s valides accept√©es (bas√©es sur l'analyse de votre base de donn√©es - 29 unit√©s trouv√©es)
        this.validUnits = [
            // Unit√©s vides
            '',
            
            // Poids et volume standard
            'g', 'kg', 'ml', 'cl', 'l', 'dl',
            
            // Cuill√®res (formats courts)
            'cs', 'cc',
            
            // Cuill√®res (formats longs) - trouv√©s dans votre DB
            'c. √† soupe', 'c. √† caf√©', 'cuill√®re √† soupe', 'cuill√®re √† caf√©',
            'cuill√®re', 'cuill√®res √† soupe', 'cuill√®res √† caf√©',
            
            // Quantit√©s et pi√®ces
            'pi√®ce', 'pi√®ces', 'piece', 'pieces', 'unit√©', 'unit√©s',
            'pc', 'pcs',
            
            // Containers et emballages
            'sachet', 'sachets', 'bo√Æte', 'conserve', 'pot', 'pots',
            'flacon', 'barquette', 'paquet', 'paquets',
            
            // Parties de plantes/l√©gumes
            'gousse', 'gousses', 'botte', 'bottes',
            'tige', 'tiges', 'branche', 'branches', 'feuille', 'feuilles',
            'tranche', 'tranches',
            
            // Autres unit√©s sp√©cialis√©es
            'cube', 'cm',
            
            // Unit√©s de dosage variables
            '√† doser', '√† r√¢per', 'selon votre go√ªt',
            
            // Anciens formats (pour r√©trocompatibilit√©)
            'pi√®ce(s)', 'sachet(s)'
        ];
    }

    /**
     * Valide la qualit√© des donn√©es d'une recette extraite
     * @param {Object} recipe - La recette √† valider
     * @param {string} rectoPath - Chemin vers l'image recto
     * @param {string} versoPath - Chemin vers l'image verso
     * @returns {Object} - La recette corrig√©e si n√©cessaire
     */
    async validateAndFixRecipe(recipe, rectoPath, versoPath) {
        // V√©rifier si la validation est activ√©e
        if (!this.config?.dataQuality?.enabled || !this.config?.dataQuality?.validateIngredients) {
            return recipe;
        }

        console.log('   üîç V√©rification de la qualit√© des donn√©es...');
        
        const issues = this.detectDataQualityIssues(recipe);
        
        if (issues.length === 0) {
            console.log('   ‚úÖ Donn√©es de qualit√© - aucune correction n√©cessaire');
            return recipe;
        }

        // V√©rifier si l'auto-correction est activ√©e
        if (!this.config?.dataQuality?.autoCorrection) {
            console.log(`   ‚ö†Ô∏è  ${issues.length} probl√®me(s) d√©tect√©(s) mais auto-correction d√©sactiv√©e`);
            return recipe;
        }

        console.log(`   ‚ö†Ô∏è  ${issues.length} probl√®me(s) d√©tect√©(s) - correction en cours...`);
        
        try {
            const correctedIngredients = await this.fixIngredientsData(
                recipe.ingredients, 
                issues, 
                rectoPath, 
                versoPath,
                recipe.title
            );
            
            // Mettre √† jour seulement les ingr√©dients corrig√©s
            const updatedRecipe = {
                ...recipe,
                ingredients: correctedIngredients
            };
            
            console.log('   ‚úÖ Donn√©es corrig√©es avec succ√®s');
            return updatedRecipe;
            
        } catch (error) {
            console.log(`   ‚ö†Ô∏è  √âchec de la correction: ${error.message}`);
            console.log('   üìù Conservation des donn√©es originales');
            return recipe;
        }
    }

    /**
     * D√©tecte les probl√®mes de qualit√© dans les ingr√©dients
     * @param {Object} recipe - La recette √† analyser
     * @returns {Array} - Liste des probl√®mes d√©tect√©s
     */
    detectDataQualityIssues(recipe) {
        const issues = [];
        
        if (!recipe.ingredients || !Array.isArray(recipe.ingredients)) {
            return issues;
        }

        recipe.ingredients.forEach((ingredient, index) => {
            const problems = [];
            
            // V√©rifier le nom
            if (!ingredient.name || typeof ingredient.name !== 'string' || ingredient.name.trim() === '') {
                problems.push('nom manquant ou vide');
            }
            
            // V√©rifier la quantit√©
            if (!ingredient.quantity || typeof ingredient.quantity !== 'object') {
                problems.push('objet quantity manquant');
            } else {
                const { value, unit } = ingredient.quantity;
                
                // V√©rifier la valeur (doit √™tre un nombre ou null)
                if (value !== null && (typeof value !== 'number' || isNaN(value))) {
                    problems.push('valeur quantity.value invalide (doit √™tre un nombre ou null)');
                }
                
                // V√©rifier l'unit√©
                if (unit === undefined || unit === null) {
                    problems.push('quantity.unit manquant');
                } else if (typeof unit !== 'string') {
                    problems.push('quantity.unit doit √™tre une cha√Æne');
                } else if (!this.isValidUnit(unit)) {
                    problems.push(`quantity.unit "${unit}" non standard`);
                }
                
                // Cas particulier: valeur null mais unit√© renseign√©e = donn√©es incompl√®tes
                if (value === null && unit && unit !== '') {
                    problems.push('valeur quantity.value manquante alors que l\'unit√© est renseign√©e');
                }
            }
            
            if (problems.length > 0) {
                issues.push({
                    index,
                    ingredient,
                    problems
                });
            }
        });
        
        return issues;
    }

    /**
     * V√©rifie si une unit√© est valide
     */
    isValidUnit(unit) {
        const normalizedUnit = unit.toLowerCase().trim();
        return this.validUnits.some(validUnit => 
            validUnit.toLowerCase() === normalizedUnit
        );
    }

    /**
     * Corrige les donn√©es des ingr√©dients via l'API OpenAI
     */
    async fixIngredientsData(ingredients, issues, rectoPath, versoPath, recipeTitle) {
        // Pr√©parer la liste des ingr√©dients probl√©matiques
        const problematicIngredients = issues.map(issue => ({
            index: issue.index,
            name: issue.ingredient.name || 'Non d√©fini',
            currentValue: issue.ingredient.quantity?.value,
            currentUnit: issue.ingredient.quantity?.unit,
            problems: issue.problems
        }));

        // Convertir les images en base64
        const ImageProcessor = require('./ImageProcessor');
        const imageProcessor = new ImageProcessor();
        const rectoBase64 = await imageProcessor.imageToBase64(rectoPath);
        const versoBase64 = await imageProcessor.imageToBase64(versoPath);

        const prompt = this.buildCorrectionPrompt(problematicIngredients, recipeTitle);
        
        const response = await this.openai.chat.completions.create({
            model: this.model,
            max_tokens: this.maxTokens,
            messages: [
                {
                    role: "system",
                    content: this.getCorrectionSystemPrompt()
                },
                {
                    role: "user",
                    content: [
                        {
                            type: "text",
                            text: prompt
                        },
                        {
                            type: "image_url",
                            image_url: {
                                url: rectoBase64,
                                detail: "high"
                            }
                        },
                        {
                            type: "image_url",
                            image_url: {
                                url: versoBase64,
                                detail: "high"
                            }
                        }
                    ]
                }
            ]
        });

        const content = response.choices[0]?.message?.content;
        if (!content) {
            throw new Error('R√©ponse vide de l\'API OpenAI pour la correction');
        }

        // Parser la r√©ponse de correction
        const corrections = this.parseCorrectionResponse(content);
        
        // Appliquer les corrections aux ingr√©dients
        return this.applyCorrections(ingredients, corrections);
    }

    /**
     * Construit le prompt pour la correction des ingr√©dients
     */
    buildCorrectionPrompt(problematicIngredients, recipeTitle) {
        return `Recette: "${recipeTitle}"

Je dois corriger les informations manquantes ou incorrectes pour ces ingr√©dients sp√©cifiques. 
Analyze attentivement les images pour extraire les quantit√©s exactes et unit√©s manquantes.

INGR√âDIENTS √Ä CORRIGER:
${problematicIngredients.map((ing, i) => 
    `${i + 1}. "${ing.name}" (index ${ing.index})
   - Valeur actuelle: ${ing.currentValue}
   - Unit√© actuelle: "${ing.currentUnit}"
   - Probl√®mes: ${ing.problems.join(', ')}`
).join('\n')}

Instructions:
- Trouve les quantit√©s exactes visibles sur les images
- Utilise des unit√©s standard (g, ml, pi√®ce, cs, cc, etc.)
- Si une quantit√© n'est vraiment pas visible, garde la valeur √† null
- Corrige le nom de l'ingr√©dient si n√©cessaire
- Ne modifie que les ingr√©dients list√©s ci-dessus`;
    }

    /**
     * Prompt syst√®me pour la correction
     */    getCorrectionSystemPrompt() {
        return `Tu es un expert en correction de donn√©es d'ingr√©dients de recettes. Tu dois analyser des images de recettes et corriger uniquement les informations manquantes ou incorrectes pour des ingr√©dients sp√©cifiques.

UNIT√âS STANDARD ACCEPT√âES:
- Poids: g, kg
- Volume: ml, cl, l, dl  
- Cuill√®res courtes: cs, cc
- Cuill√®res longues: c. √† soupe, c. √† caf√©, cuill√®re, cuill√®re √† soupe, cuill√®re √† caf√©, cuill√®res √† soupe, cuill√®res √† caf√©
- Quantit√©s: pi√®ce, pi√®ces, piece, pieces, unit√©, unit√©s, pc, pcs
- Containers: sachet, sachets, bo√Æte, pot, pots, conserve, barquette, paquet, paquets, flacon
- V√©g√©taux: gousse, gousses, botte, bottes, tige, tiges, branche, branches, feuille, feuilles, tranche, tranches
- Autres: cube, cm, √† doser, √† r√¢per
- Vide ("") pour les √©l√©ments sans unit√© sp√©cifique

R√âPONSE REQUISE - Format JSON uniquement:
{
  "corrections": [
    {
      "index": 0,
      "name": "Nom correct de l'ingr√©dient",
      "quantity": {
        "value": 150,
        "unit": "g"
      }
    }
  ]
}

R√àGLES:
1. Ne corriger QUE les ingr√©dients mentionn√©s dans la requ√™te
2. Si une quantit√© n'est pas visible, mettre "value": null
3. Toujours renseigner l'unit√© si elle est identifiable
4. Utiliser les noms d'ingr√©dients exacts visibles sur l'image
5. R√©pondre uniquement avec le JSON, sans explication`;
    }

    /**
     * Parse la r√©ponse de correction
     */
    parseCorrectionResponse(content) {
        try {
            // Nettoyer la r√©ponse pour extraire uniquement le JSON
            let jsonStr = content.trim();
            jsonStr = jsonStr.replace(/```json\s*/, '').replace(/```\s*$/, '');
            
            const response = JSON.parse(jsonStr);
            
            if (!response.corrections || !Array.isArray(response.corrections)) {
                throw new Error('Format de r√©ponse incorrect: corrections manquantes');
            }
            
            return response.corrections;
            
        } catch (error) {
            console.error('   ‚ùå Erreur lors du parsing de la correction:', error.message);
            console.error('   üìÑ Contenu re√ßu:', content);
            throw new Error(`Impossible de parser la r√©ponse de correction: ${error.message}`);
        }
    }

    /**
     * Applique les corrections aux ingr√©dients
     */
    applyCorrections(originalIngredients, corrections) {
        const correctedIngredients = [...originalIngredients];
        
        corrections.forEach(correction => {
            if (correction.index >= 0 && correction.index < correctedIngredients.length) {
                const originalIngredient = correctedIngredients[correction.index];
                
                // Mettre √† jour seulement si les donn√©es de correction sont valides
                if (correction.name && correction.name.trim() !== '') {
                    originalIngredient.name = correction.name.trim();
                }
                
                if (correction.quantity && typeof correction.quantity === 'object') {
                    if (!originalIngredient.quantity) {
                        originalIngredient.quantity = {};
                    }
                    
                    // Mettre √† jour la valeur
                    if (correction.quantity.hasOwnProperty('value')) {
                        originalIngredient.quantity.value = correction.quantity.value;
                    }
                    
                    // Mettre √† jour l'unit√©
                    if (correction.quantity.hasOwnProperty('unit')) {
                        originalIngredient.quantity.unit = correction.quantity.unit;
                    }
                }
                  console.log(`   ‚úèÔ∏è  Corrig√©: "${originalIngredient.name}" - ${originalIngredient.quantity.value || 'null'} ${originalIngredient.quantity.unit}`);
            }
        });
        
        return correctedIngredients;
    }
}

module.exports = DataQualityValidator;
